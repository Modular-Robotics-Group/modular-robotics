// Generated by CoffeeScript 2.5.1
(function() {
  /*
  * link to parent
  * sibling copy
  * a-z, 1-9 indexing of rows/columns for easy communication
  * scale?
  * scrollbar?
   */
  var Board, Boards, autosize, board, boardSVG, boardView, boards, buttonStroke, color, colors, doOp, dragScale, dragStart, dragging, headerSize, index, initBoards, initPalette, j, len, load, minus, name, nameMapping, newName, oldName, palette, paletteByName, paletteSelect, plus, redo, redoStack, resize, save, scaleFactor, selected, tileSize, tool, undo, undoStack, undoableOp,
    hasProp = {}.hasOwnProperty;

  //# Colors from Cocreate:
  colors = {
    //wt: 'white'
    gy: '#bbbbbb',
    Gy: '#989898',
    GY: '#666666',
    bk: 'black',
    BL: '#333399',
    bl: '#3366ff',
    cy: '#00c7c7',
    GR: '#008000',
    gr: '#00c000',
    PR: '#800080',
    pr: '#d000d0',
    RD: '#a00000',
    rd: '#ff0000',
    or: '#ed8e00',
    yl: '#eced00'
  };

  palette = [
    {
      name: '?',
      svg: '<rect x="0" y="0" width="50" height="50" fill="white" stroke="gray"/>'
    },
    {
      name: '?c',
      svg: '<g><rect x="0" y="0" width="50" height="50" fill="white" stroke="gray"/><circle cx="25" cy="25" r="15" fill="red"/></g>'
    }
  ];

  for (name in colors) {
    color = colors[name];
    palette.push({
      name: name,
      svg: `<rect x="0" y="0" width="50" height="50" fill="${color}" stroke="black"/>`
    });
    palette.push({
      name: `${name}c`,
      svg: `<g><rect x="0" y="0" width="50" height="50" fill="${color}" stroke="black"/><circle cx="25" cy="25" r="14" fill="${name === 'rd' ? '#a00000' : '#ff0000'}"/></g>`
    });
  }

  paletteByName = {};

  for (index = j = 0, len = palette.length; j < len; index = ++j) {
    tool = palette[index];
    paletteByName[tool.name] = index;
  }

  //# Old symbols for compatibility:
  //palette.push ...[
  //  name: '0'
  //  svg: '<rect x="0" y="0" width="50" height="50" fill="#eff243" stroke="black"/>'
  //,
  //  name: '1'
  //  svg: '<rect x="0" y="0" width="50" height="50" fill="#4b0082" stroke="black"/>'
  //,
  //  name: '0c'
  //  svg: '<g><rect x="0" y="0" width="50" height="50" fill="#eff243" stroke="black"/><circle cx="25" cy="25" r="15" fill="red"/></g>'
  //,
  //  name: '1c'
  //  svg: '<g><rect x="0" y="0" width="50" height="50" fill="#4b0082" stroke="black"/><circle cx="25" cy="25" r="15" fill="red"/></g>'
  //,
  //  name: 'n0'
  //  svg: '<rect x="0" y="0" width="50" height="50" fill="#2874a6" stroke="black"/>'
  //,
  //  name: 'n1'
  //  svg: '<rect x="0" y="0" width="50" height="50" fill="#32722c" stroke="black"/>'
  //,
  //  name: 'n2'
  //  svg: '<rect x="0" y="0" width="50" height="50" fill="#cc8933" stroke="black"/>'
  //,
  //  name: 'n3'
  //  svg: '<rect x="0" y="0" width="50" height="50" fill="#a40000" stroke="black"/>'
  nameMapping = {
    '0': 'yl',
    '1': 'PR',
    '0c': 'ylc',
    '1c': 'PRc',
    'n0': 'bl',
    'n1': 'GR',
    'n2': 'or',
    'n3': 'RD'
  };

  for (oldName in nameMapping) {
    newName = nameMapping[oldName];
    paletteByName[oldName] = paletteByName[newName];
  }

  tileSize = 50;

  headerSize = 20;

  //headerSvg = """<g><rect x="0" y="0" width="#{250-headerSize}" height="#{headerSize}" fill="purple"/><rect x="#{250-headerSize}" y="0" width="#{headerSize}" height="#{headerSize}" fill="red"/></g>"""
  board = [];

  selected = {};

  undoStack = [];

  redoStack = [];

  scaleFactor = 0.5;

  buttonStroke = {
    width: 0.25 * headerSize,
    color: 'yellow',
    linecap: 'round'
  };

  paletteSelect = function(button, index) {
    var k, l, len1, len2, results, select, tile;
    selected[button] = index % palette.length;
    for (k = 0, len1 = palette.length; k < len1; k++) {
      tile = palette[k];
      tile.rgb = [255, 255, 255];
    }
    for (button in selected) {
      select = selected[button];
      palette[select].rgb[button % 3] = 0;
    }
    results = [];
    for (l = 0, len2 = palette.length; l < len2; l++) {
      tile = palette[l];
      results.push(tile.div.css('border-color', `rgb(${tile.rgb[0]},${tile.rgb[1]},${tile.rgb[2]}`));
    }
    return results;
  };

  initPalette = function() {
    var i, k, len1;
    for (i = k = 0, len1 = palette.length; k < len1; i = ++k) {
      tool = palette[i];
      (function(i) {
        var click, div;
        tool.div = div = $('<div>').addClass('tool').appendTo('#palette').click(click = function(e) {
          return paletteSelect(e.button, i);
        }).on('contextmenu', function(e) {
          e.preventDefault();
          e.stopPropagation();
          return click(e);
        });
        return tool.SVG = SVG(div[0]).size(tileSize, tileSize).svg(tool.svg);
      })(i);
    }
    paletteSelect(0, 2);
    paletteSelect(2, 0);
    return null;
  };

  boardSVG = boardView = null;

  dragging = dragStart = dragScale = null;

  boards = null;

  autosize = {};

  //resize = ->
  //  bbox = boards[0].bbox()
  //  for board in boards[1..]
  //    bbox.merge board.bbox()
  //  console.log bbox
  //  gui = $ '#svg'
  //  gui.css 'width', Math.max 100, bbox.width
  //  gui.css 'height', Math.max 100, bbox.height
  plus = function(group, fill = 'red', stroke = buttonStroke) {
    var coords, k, len1, ref, results;
    group.rect(headerSize, headerSize).fill(fill);
    ref = [[0.5 * headerSize, 0.2 * headerSize, 0.5 * headerSize, 0.8 * headerSize], [0.2 * headerSize, 0.5 * headerSize, 0.8 * headerSize, 0.5 * headerSize]];
    results = [];
    for (k = 0, len1 = ref.length; k < len1; k++) {
      coords = ref[k];
      results.push(group.line(...coords).stroke(stroke));
    }
    return results;
  };

  minus = function(group, fill = 'red', stroke = buttonStroke) {
    var coords, k, len1, ref, results;
    group.rect(headerSize, headerSize).fill(fill);
    ref = [[0.2 * headerSize, 0.5 * headerSize, 0.8 * headerSize, 0.5 * headerSize]];
    results = [];
    for (k = 0, len1 = ref.length; k < len1; k++) {
      coords = ref[k];
      results.push(group.line(...coords).stroke(stroke));
    }
    return results;
  };

  initBoards = function() {
    var k, len1;
    boardSVG = SVG('svg').mousemove(function(e) {
      if (dragging != null) {
        dragging.g.transform({
          x: dragStart.x + e.x / dragScale,
          y: dragStart.y + e.y / dragScale
        });
        return boards.updateSize();
      }
    }).mouseup(function() {
      var id, ref;
      dragging = null;
      for (id in autosize) {
        if ((ref = boards[id]) != null) {
          if (typeof ref.autosize === "function") {
            ref.autosize();
          }
        }
      }
      return autosize = {};
    }).on('mouseleave', function(e) {
      return dragging = null;
    }).mousedown(function(e) {
      dragScale = 1;
      dragging = boards;
      return dragStart = {
        x: -e.x / dragScale + boardView.transform('x'),
        y: -e.y / dragScale + boardView.transform('y')
      };
    }).on('contextmenu', function(e) {
      e.preventDefault();
      return e.stopPropagation();
    });
    for (k = 0, len1 = palette.length; k < len1; k++) {
      tool = palette[k];
      tool.def = boardSVG.defs().group().svg(tool.svg);
    }
    boardView = boardSVG.group().scale(scaleFactor);
    boards = new Boards();
    return boards.g = boardView;
  };

  Boards = class Boards {
    clear() {
      var id, k, len1, ref, results;
      ref = this.boardIds();
      results = [];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        id = ref[k];
        results.push(delete this[id]);
      }
      return results;
    }

    boardIds() {
      var id, ref, results;
      ref = this;
      results = [];
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        if (!isNaN(parseInt(id))) {
          results.push(id);
        }
      }
      return results;
    }

    toJSON() {
      var d, id, k, len1, ref;
      d = {};
      ref = this.boardIds();
      for (k = 0, len1 = ref.length; k < len1; k++) {
        id = ref[k];
        d[id] = this[id];
      }
      return d;
    }

    updateSize() {
      var bbox;
      bbox = boardSVG.bbox();
      $(boardSVG.node).css('min-width', bbox.x + bbox.width + 2 * tileSize);
      return $(boardSVG.node).css('min-height', bbox.y + bbox.height + tileSize);
    }

  };

  Board = (function() {
    class Board {
      constructor(x = 0, y = 0, nx = Board.minSize, ny = Board.minSize, set = 0, parent = null, id1 = null) {
        this.parent = parent;
        this.id = id1;
        if (this.id != null) {
          Board.maxId = Math.max(Board.maxId, this.id);
        } else {
          this.id = ++Board.maxId;
        }
        this.g = boardView.group().translate(x, y);
        this.header = this.g.group();
        this.titleBar = this.header.rect(nx * tileSize - 2 * headerSize, headerSize).fill('purple').mousedown((e) => {
          if (!(e.buttons & 1)) {
            return;
          }
          e.stopPropagation();
          dragScale = scaleFactor;
          dragging = this;
          return dragStart = {
            x: -e.x / dragScale + this.x(),
            y: -e.y / dragScale + this.y()
          };
        });
        //console.log dragging, dragStart
        this.downloadButton = this.header.group().click((e) => {
          var blob, svg;
          svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${this.nx() * tileSize} ${this.ny() * tileSize}" preserveAspectRatio="xMinYMin meet">
${boardSVG.defs().svg()}
${this.body.svg().replace(/transform="[^"]*"/, '')}
</svg>`;
          blob = new Blob([svg], {
            type: "image/svg+xml"
          });
          document.getElementById('svglink').href = URL.createObjectURL(blob);
          document.getElementById('svglink').download = 'drawing.svg';
          return document.getElementById('svglink').click();
        });
        this.downloadButton.rect(headerSize, headerSize).fill('red');
        this.downloadButton.line([[0.2 * headerSize, 0.3 * headerSize], [0.5 * headerSize, 0.65 * headerSize]]).stroke(buttonStroke);
        this.downloadButton.line([[0.5 * headerSize, 0.65 * headerSize], [0.8 * headerSize, 0.3 * headerSize]]).stroke(buttonStroke);
        this.copyButton = this.header.group().mousedown((e) => {
          if (!(e.buttons & 1)) {
            return;
          }
          e.stopPropagation();
          dragScale = scaleFactor;
          dragging = this.copy();
          return dragStart = {
            x: -e.x / dragScale + this.x(),
            y: -e.y / dragScale + this.y()
          };
        });
        plus(this.copyButton);
        this.body = this.g.group().translate(0, headerSize);
        this.buttons = this.g.group().translate(0, headerSize);
        this.init(nx, ny, set);
        boards[this.id] = this;
        boards.updateSize();
      }

      //resize()
      init(nx, ny, set = 0) {
        var button, k, l, m, n, o, p, ref, ref1, ref2, ref3, ref4, ref5, results, x, y;
        this.titleBar.width(nx * tileSize - headerSize);
        this.copyButton.transform({
          x: nx * tileSize - headerSize
        });
        this.body.clear();
        this.buttons.clear();
        this.board = [];
        button = null;
        for (x = k = 0, ref = nx; (0 <= ref ? k < ref : k > ref); x = 0 <= ref ? ++k : --k) {
          this.board.push([]);
          for (y = l = 0, ref1 = ny; (0 <= ref1 ? l < ref1 : l > ref1); y = 0 <= ref1 ? ++l : --l) {
            ((x, y) => {
              this.board[x][y] = {
                g: this.body.group().translate(x * tileSize, y * tileSize).mousedown((e) => {
                  var after, ref2;
                  e.stopPropagation();
                  after = (ref2 = selected[e.button]) != null ? ref2 : 0;
                  undoableOp({
                    type: 'set',
                    board: this,
                    sets: [
                      {
                        x,
                        y,
                        after,
                        before: this.get(x,
                      y)
                      }
                    ]
                  });
                  this.set(x, y, after);
                  autosize[this.id] = true;
                  window.addModuleAtPosition(x, y, 0);
                  return button = e.button;
                }).mouseover((e) => {
                  var after, ref2;
                  if (dragging != null) {
                    return;
                  }
                  if (e.buttons) {
                    after = (ref2 = selected[button]) != null ? ref2 : 0;
                    undoStack[undoStack.length - 1].sets.push({
                      x,
                      y,
                      after,
                      before: this.get(x, y)
                    });
                    this.set(x, y, after);
                  }
                  return autosize[this.id] = true;
                })
              };
              if (set != null) {
                return this.set(x, y, set);
              }
            })(x, y);
          }
        }
        for (x = m = 1, ref2 = nx; (1 <= ref2 ? m < ref2 : m > ref2); x = 1 <= ref2 ? ++m : --m) {
          ((x) => {
            var b, click;
            b = this.buttons.group().translate(x * tileSize - headerSize / 2, ny * tileSize).click(click = (e) => {
              return this.addColumn(x, e.button);
            }).on('contextmenu', function(e) {
              e.preventDefault();
              e.stopPropagation();
              return click(e);
            });
            return plus(b, 'blue');
          })(x);
        }
        for (x = n = 1, ref3 = nx - 1; (1 <= ref3 ? n < ref3 : n > ref3); x = 1 <= ref3 ? ++n : --n) {
          ((x) => {
            var b, click;
            b = this.buttons.group().translate((x + 1 / 2) * tileSize - headerSize / 2, ny * tileSize).click(click = (e) => {
              return this.removeColumn(x);
            }).on('contextmenu', function(e) {
              e.preventDefault();
              e.stopPropagation();
              return click(e);
            });
            return minus(b, 'red');
          })(x);
        }
        for (y = o = 1, ref4 = ny; (1 <= ref4 ? o < ref4 : o > ref4); y = 1 <= ref4 ? ++o : --o) {
          ((y) => {
            var b, click;
            b = this.buttons.group().translate(nx * tileSize, y * tileSize - headerSize / 2).click(click = (e) => {
              return this.addRow(y, e.button);
            }).on('contextmenu', function(e) {
              e.preventDefault();
              e.stopPropagation();
              return click(e);
            });
            return plus(b, 'blue');
          })(y);
        }
        results = [];
        for (y = p = 1, ref5 = ny - 1; (1 <= ref5 ? p < ref5 : p > ref5); y = 1 <= ref5 ? ++p : --p) {
          results.push(((y) => {
            var b, click;
            b = this.buttons.group().translate(nx * tileSize, (y + 1 / 2) * tileSize - headerSize / 2).click(click = (e) => {
              return this.removeRow(y, e.button);
            }).on('contextmenu', function(e) {
              e.preventDefault();
              e.stopPropagation();
              return click(e);
            });
            return minus(b, 'red');
          })(y));
        }
        return results;
      }

      x() {
        return this.g.transform('x');
      }

      y() {
        return this.g.transform('y');
      }

      nx() {
        return this.board.length;
      }

      ny() {
        return this.board[0].length;
      }

      bbox() {
        var box, x, y;
        box = this.g.bbox();
        x = this.x();
        y = this.y();
        box.x += x;
        box.cx += cx;
        box.x2 += x;
        box.y += y;
        box.cy += cy;
        box.y2 += y;
        return box;
      }

      get(x, y) {
        return this.board[x][y].index;
      }

      set(x, y, index) {
        this.board[x][y].index = index;
        this.board[x][y].g.clear();
        return this.board[x][y].g.use(palette[index].def);
      }

      copy() {
        var c, cell, k, l, len1, len2, ref, row, x, y;
        c = new Board(this.x(), this.y(), this.nx(), this.ny(), null, this.id);
        ref = this.board;
        for (x = k = 0, len1 = ref.length; k < len1; x = ++k) {
          row = ref[x];
          for (y = l = 0, len2 = row.length; l < len2; y = ++l) {
            cell = row[y];
            c.set(x, y, cell.index);
          }
        }
        return c;
      }

      delete() {
        delete boards[this.id];
        return this.g.remove();
      }

      resize(dnx, dny, dx, dy, skip) {
        var k, l, len1, len2, m, n, nx, ny, old, op, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, set, x, xold, y, yold;
        old = this.board;
        nx = this.nx() + dnx;
        ny = this.ny() + dny;
        this.init(nx, ny, null);
        for (x = k = 0, ref = nx; (0 <= ref ? k < ref : k > ref); x = 0 <= ref ? ++k : --k) {
          for (y = l = 0, ref1 = ny; (0 <= ref1 ? l < ref1 : l > ref1); y = 0 <= ref1 ? ++l : --l) {
            if ((skip != null) && skip(x, y)) {
              this.set(x, y, 0);
              continue;
            }
            if (typeof dx === 'function') {
              xold = x - dx(x, y);
            } else {
              xold = x - dx;
            }
            if (typeof dy === 'function') {
              yold = y - dy(x, y);
            } else {
              yold = y - dy;
            }
            this.set(x, y, (ref2 = (ref3 = old[xold]) != null ? (ref4 = ref3[yold]) != null ? ref4.index : void 0 : void 0) != null ? ref2 : 0);
          }
        }
        ref5 = undoStack.concat(redoStack);
        for (m = 0, len1 = ref5.length; m < len1; m++) {
          op = ref5[m];
          if (op.board === this) {
            ref7 = (ref6 = op.sets) != null ? ref6 : [];
            for (n = 0, len2 = ref7.length; n < len2; n++) {
              set = ref7[n];
              if (typeof dx !== 'function') {
                set.x += dx;
              }
              if (typeof dy !== 'function') {
                set.y += dy;
              }
            }
            switch (op.type) {
              case 'Row':
                if (typeof dy !== 'function') {
                  op.coord += dy;
                }
                break;
              case 'Column':
                if (typeof dx !== 'function') {
                  op.coord += dx;
                }
            }
          }
        }
        return boards.updateSize();
      }

      row(coord) {
        var column, k, len1, ref, results;
        ref = this.board;
        results = [];
        for (k = 0, len1 = ref.length; k < len1; k++) {
          column = ref[k];
          results.push(column[coord].index);
        }
        return results;
      }

      column(coord) {
        var cell, k, len1, ref, results;
        ref = this.board[coord];
        results = [];
        for (k = 0, len1 = ref.length; k < len1; k++) {
          cell = ref[k];
          results.push(cell.index);
        }
        return results;
      }

      addRow(coord, copy, undoable = true) {
        var k, len1, x;
        this.resize(0, 1, 0, (function(x, y) {
          return y >= coord; // dy
        }), (function(x, y) {
          return !copy && y === coord; // skip
        }));
        if (Array.isArray(copy)) {
          for (x = k = 0, len1 = copy.length; k < len1; x = ++k) {
            index = copy[x];
            this.set(x, coord, index);
          }
        }
        if (undoable) {
          return undoableOp({
            type: 'Row',
            add: true,
            board: this,
            coord: coord,
            content: this.row(coord)
          });
        }
      }

      addColumn(coord, copy, undoable = true) {
        var k, len1, y;
        this.resize(1, 0, (function(x, y) {
          return x >= coord;
        }), 0, (function(x, y) { // dx, dy
          return !copy && x === coord; // skip
        }));
        if (Array.isArray(copy)) {
          for (y = k = 0, len1 = copy.length; k < len1; y = ++k) {
            index = copy[y];
            this.set(coord, y, index);
          }
        }
        if (undoable) {
          return undoableOp({
            type: 'Column',
            add: true,
            board: this,
            coord: coord,
            content: this.column(coord)
          });
        }
      }

      removeRow(coord, undoable = true) {
        if (undoable) {
          undoableOp({
            type: 'Row',
            add: false,
            board: this,
            coord: coord,
            content: this.row(coord)
          });
        }
        return this.resize(0, -1, 0, (function(x, y) {
          return -(y >= coord); // dy
        }));
      }

      removeColumn(coord, undoable = true) {
        if (undoable) {
          undoableOp({
            type: 'Column',
            add: false,
            board: this,
            coord: coord,
            content: this.column(coord)
          });
        }
        return this.resize(-1, 0, (function(x, y) {
          return -(x >= coord);
        }), 0); // dx, dy
      }

      emptyX(x) {
        var cell, k, len1, ref;
        ref = this.board[x];
        for (k = 0, len1 = ref.length; k < len1; k++) {
          cell = ref[k];
          if (cell.index !== 0) {
            return false;
          }
        }
        return true;
      }

      emptyY(y) {
        var k, len1, ref, row;
        ref = this.board;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          row = ref[k];
          if (row[y].index !== 0) {
            return false;
          }
        }
        return true;
      }

      autosize() {
        var k, l, m, n, ref, ref1, ref2, ref3, x, y;
//# Left
        for (x = k = 0, ref = this.nx(); (0 <= ref ? k < ref : k > ref); x = 0 <= ref ? ++k : --k) {
          if (!this.emptyX(x)) {
            break;
          }
        }
        if (x === 0) { //# no blanks: grow
          this.resize(1, 0, 1, 0);
        } else {
          x -= 1; //# leave one blank on side
          x = Math.min(x, this.nx() - Board.minSize); //# size at least Board.minSize
          if (x > 0) {
            this.resize(-x, 0, -x, 0);
          }
        }
//# Right
        for (x = l = ref1 = this.nx() - 1; (ref1 <= 0 ? l <= 0 : l >= 0); x = ref1 <= 0 ? ++l : --l) {
          if (!this.emptyX(x)) {
            break;
          }
        }
        if (x === this.nx() - 1) { //# no blanks: grow
          this.resize(1, 0, 0, 0);
        } else {
          x += 2; //# leave one blank
          x = Math.max(x, Board.minSize); //# size at least Board.minSize
          if (x < this.nx()) {
            this.resize(x - this.nx(), 0, 0, 0);
          }
        }
//# Top
        for (y = m = 0, ref2 = this.ny(); (0 <= ref2 ? m < ref2 : m > ref2); y = 0 <= ref2 ? ++m : --m) {
          if (!this.emptyY(y)) {
            break;
          }
        }
        if (y === 0) { //# no blanks: grow
          this.resize(0, 1, 0, 1);
        } else {
          y -= 1; //# leave one blank on side
          y = Math.min(y, this.ny() - Board.minSize); //# size at least Board.minSize
          if (y > 0) {
            this.resize(0, -y, 0, -y);
          }
        }
//# Bottom
        for (y = n = ref3 = this.ny() - 1; (ref3 <= 0 ? n <= 0 : n >= 0); y = ref3 <= 0 ? ++n : --n) {
          if (!this.emptyY(y)) {
            break;
          }
        }
        if (y === this.ny() - 1) { //# no blanks: grow
          return this.resize(0, 1, 0, 0);
        } else {
          y += 2; //# leave one blank
          y = Math.max(y, Board.minSize); //# size at least Board.minSize
          if (y < this.ny()) {
            return this.resize(0, y - this.ny(), 0, 0);
          }
        }
      }

      toJSON() {
        var cell, row;
        return {
          parent: this.parent,
          board: (function() {
            var k, len1, ref, results;
            ref = this.board;
            results = [];
            for (k = 0, len1 = ref.length; k < len1; k++) {
              row = ref[k];
              results.push((function() {
                var l, len2, results1;
                results1 = [];
                for (l = 0, len2 = row.length; l < len2; l++) {
                  cell = row[l];
                  results1.push(palette[cell.index].name);
                }
                return results1;
              })());
            }
            return results;
          }).call(this),
          x: this.x(),
          y: this.y()
        };
      }

      static fromJSON(id, json) {
        var b, cell, k, l, len1, len2, ref, ref1, ref2, row, x, y;
        b = new this((ref = json.x) != null ? ref : 0, (ref1 = json.y) != null ? ref1 : 0, json.board.length, json.board[0].length, null, json.parent, id);
        ref2 = json.board;
        for (x = k = 0, len1 = ref2.length; k < len1; x = ++k) {
          row = ref2[x];
          for (y = l = 0, len2 = row.length; l < len2; y = ++l) {
            cell = row[y];
            b.set(x, y, paletteByName[cell]);
          }
        }
        b.autosize();
        return b;
      }

    };

    Board.maxId = -1;

    Board.minSize = 3;

    return Board;

  }).call(this);

  resize = function() {};

  //gui = $ '#svg'
  //gui.css 'height', Math.max 100, Math.floor(window.innerHeight - gui[0].getBoundingClientRect().top - 50)
  save = function() {
    boards.x = boardView.transform('x');
    boards.y = boardView.transform('y');
    return JSON.stringify(boards);
  };

  load = function(json) {
    var id, results;
    json = JSON.parse(json);
    boardView.clear();
    boardView.transform({
      x: json.x,
      y: json.y
    });
    boards.clear();
    Board.maxId = -1;
//# for x and y properties
    results = [];
    for (id in json) {
      board = json[id];
      if (!isNaN(parseInt(id))) {
        results.push(Board.fromJSON(id, board));
      }
    }
    return results;
  };

  undoableOp = function(op) {
    undoStack.push(op);
    return redoStack = [];
  };

  undo = function() {
    var op;
    if (!undoStack.length) {
      return;
    }
    redoStack.push(op = undoStack.pop());
    return doOp(op, true);
  };

  redo = function() {
    var op;
    if (!redoStack.length) {
      return;
    }
    undoStack.push(op = redoStack.pop());
    return doOp(op, false);
  };

  doOp = function(op, reversed) {
    var add, currX, currY, dx, dy, k, len1, maxX, maxY, minX, minY, set, sets;
    switch (op.type) {
      case 'set':
        sets = op.sets.slice(0);
        if (reversed) {
          sets = sets.reverse();
        }
        minX = Math.min(0, ...((function() {
          var k, len1, results;
          results = [];
          for (k = 0, len1 = sets.length; k < len1; k++) {
            set = sets[k];
            results.push(set.x);
          }
          return results;
        })()));
        minY = Math.min(0, ...((function() {
          var k, len1, results;
          results = [];
          for (k = 0, len1 = sets.length; k < len1; k++) {
            set = sets[k];
            results.push(set.y);
          }
          return results;
        })()));
        currX = op.board.nx() - 1;
        currY = op.board.ny() - 1;
        maxX = Math.max(currX, ...((function() {
          var k, len1, results;
          results = [];
          for (k = 0, len1 = sets.length; k < len1; k++) {
            set = sets[k];
            results.push(set.x);
          }
          return results;
        })()));
        maxY = Math.max(currY, ...((function() {
          var k, len1, results;
          results = [];
          for (k = 0, len1 = sets.length; k < len1; k++) {
            set = sets[k];
            results.push(set.y);
          }
          return results;
        })()));
        if (minX < 0 || minY < 0 || maxX > currX || maxY > currY) {
          dx = -minX + 1;
          dy = -minY + 1;
          op.board.resize(dx + (maxX - currX), dy + (maxY - currY), dx, dy);
        }
        for (k = 0, len1 = sets.length; k < len1; k++) {
          set = sets[k];
          op.board.set(set.x, set.y, reversed ? set.before : set.after);
        }
        return op.board.autosize();
      case 'Row':
      case 'Column':
        add = op.add;
        if (reversed) {
          add = !add;
        }
        if (add) {
          return op.board[`add${op.type}`](op.coord, op.content, false);
        } else {
          return op.board[`remove${op.type}`](op.coord, false);
        }
        break;
      default:
        return console.warn(`Unrecognize op type ${op.type}`);
    }
  };

  window.onload = function() {
    initPalette();
    initBoards();
    new Board();
    $(window).resize(resize).keydown(function(e) {
      var ref;
      switch (e.key) {
        case ' ':
        case 'Tab':
          paletteSelect(0, ((ref = selected[0]) != null ? ref : 0) + 1);
          e.stopPropagation();
          return e.preventDefault();
        case '1':
          return paletteSelect(0, 0);
        case '2':
          return paletteSelect(0, 1);
        case '3':
          return paletteSelect(0, 2);
        case '4':
          return paletteSelect(0, 3);
        case '5':
          return paletteSelect(0, 4);
        case '6':
          return paletteSelect(0, 5);
        case '7':
          return paletteSelect(0, 6);
        case '8':
          return paletteSelect(0, 7);
        case '9':
          return paletteSelect(0, 8);
        case '0':
          return paletteSelect(0, 9);
        //when 'Backspace', 'Delete'
        case 'd':
        case 'D':
          if ((dragging != null) && (dragging.id != null)) { //# Board?
            dragging.delete();
            return dragging = null;
          }
          break;
        case 'z':
          return undo();
        case 'y':
        case 'Z':
          return redo();
      }
    });
    $('#save').click(function() {
      return $('#file').val(save());
    });
    $('#load').click(function() {
      return load($('#file').val());
    });
    $('#undo').click(undo);
    $('#redo').click(redo);
    resize();
    return null;
  };

}).call(this);
